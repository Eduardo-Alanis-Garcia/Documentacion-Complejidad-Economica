---
title: "Documentación Tablero de Complejidad Económica"
author: "Eduardo Alanis Garcia"
format: html
editor: visual
---

# Actualización del Tablero

![Vista general del tablero](Img/General_tablero.PNG){fig-align="center"}

El propósito de este documento es presentar la actualización de los datos correspondientes a los nuevos periodos del **Tablero de Complejidad Económica**, disponible en [SIGEH Hidalgo](http://sigeh.hidalgo.gob.mx:81/).

Esta actualización se centra exclusivamente en la obtención e incorporación de los datos que se muestran en las gráficas. No se realizan modificaciones al código de la aplicación, el cual se mantiene desarrollado en **Python Dash**.

Las ideas y metodologías utilizadas en el tablero se basan principalmente en:

-   [DATA MÉXICO — Complejidad económica](https://www.economia.gob.mx/datamexico/es/profile/economic_complexity/1)\
-   [OEC — Observatory of Economic Complexity](https://oec.world/es/profile/country/mex)\
-   [*The Atlas of Economic Complexity: Mapping Paths to Prosperity* (PDF)](https://growthlab.hks.harvard.edu/files/growthlab/files/atlas_2013_part1.pdf)\
-   [Documentación R: package *economiccomplexity* (CRAN)](https://cran.r-project.org/web/packages/economiccomplexity/refman/economiccomplexity.html)
-   [Mis notas](https://www.overleaf.com/project/67be428161599fd288d9a578)

## Obtención de los datos

Los datos se obtendrán a partir de la descarga masiva del [***Directorio Estadístico Nacional de Unidades Económicas (DENUE).***](https://www.inegi.org.mx/app/descarga/?ti=6)

![](Img/Denue_Carga.PNG)

Se realizarán dos descargas:

-   **Hidalgo**

-   **Nivel Nacional**

Para el caso de **Hidalgo**, dentro de la página del DENUE utilizaremos los filtros para seleccionar la entidad y descargar el archivo en formato CSV. En este ejercicio trabajaremos con la base correspondiente a **mayo 2025.**

![](Img/Denue_Hidalgo.PNG)

**Recomendaciones para organizar la información:**

-   Descargar el archivo.

-   Guardarlo en una carpeta específica (ejemplo: *`Datos → Originales → Hidalgo`*).

-   Renombrar el archivo según el periodo:

    -   **2025A →** Primer periodo 2025.

    -   **2025B →** Segundo periodo 2025.

![](Img/Descarga%20Hidalgo.PNG)

![](Img/Descarga%20Hidalgo%20Renombrar.PNG)

Por otro lado, cuando es a **nivel nacional** dentro de la página del DENUE utilizaremos los filtros para seleccionar **Estados Unidos Mexicanos** y descargar los 25 archivos CSV.

![](Img/Denue_Nacional.PNG)

**Recomendaciones para organizar la información:**

-   Descargar los archivos.

-   Guardarlo en una carpeta específica (ejemplo: *`Datos → Originales → Nacional`*).

-   Creamos una carpeta según el periodo:

    -   **2025A →** Primer periodo 2025.

    -   **2025B →** Segundo periodo 2025.

Añadimos todos los archivos descargados a esa carpeta.

![](Img/Descarga%20Nacional%20Carpeta.PNG)

![](Img/Descarga%20Nacional%20Todos.PNG)

#### Descomprimir archivos

Descomprime los archivos de **Hidalgo**. Solo indica la carpeta donde los guardaste y cambia la línea con esa ruta.

```{r descomprimir_hidalgo}
directorio = "Datos/Originales/Hidalgo/"
archivos_zip = list.files(path = directorio, recursive = TRUE, full.names = TRUE, pattern = "\\.zip")

for (zip_file in archivos_zip) {
  
  nombre_carpeta = tools::file_path_sans_ext(basename(zip_file))
  
  # Carpeta destino 
  destino = file.path(dirname(zip_file), nombre_carpeta)
  
  # Crear carpeta si no existe
  if (!dir.exists(destino)) {
    dir.create(destino, recursive = TRUE)
  }
  
  # Extraer dentro de la carpeta
  unzip(zip_file, exdir = destino)
  
  message("Extraído: ", zip_file, " → ", destino)
}
```

![](Img/Descomprimir_Hidalgo.png)

De manera analoga los archivos **nivel nacional**. Solo indica la carpeta donde los guardaste y cambia la línea con esa ruta.

```{r descomprimir_nacional}
directorio = "Datos/Originales/Nacional/2025A"
archivos_zip = list.files(path = directorio, recursive = TRUE, full.names = TRUE, pattern = "\\.zip")

for (zip_file in archivos_zip) {
  
  nombre_carpeta = tools::file_path_sans_ext(basename(zip_file))
  
  # Carpeta destino 
  destino = file.path(dirname(zip_file), nombre_carpeta)
  
  # Crear carpeta si no existe
  if (!dir.exists(destino)) {
    dir.create(destino, recursive = TRUE)
  }
  
  # Extraer dentro de la carpeta
  unzip(zip_file, exdir = destino)
  
  message("Extraído: ", zip_file, " → ", destino)
}
```

![](Img/Descomprimir_nacional.png)

## Índice de Complejidad Económica

El Índice de Complejidad Económica (ECI) es una medida de las habilidades y capacidades técnicas implícitas con las que cuenta una región, el cual captura qué tan compleja es una economía identificando tanto las actividades que puede desarrollar con éxito como en qué otros lugares están presentes esas actividades. Una región con un ECI alto indica que las actividades realizadas en la región requieren capacidades técnicas y habilidades más especializadas. El ECI se calculó con una estimación del número de trabajadores en cada industria y el número de unidades económicas dedicadas a cada industria.

![](Img/ICE_Vista_General.png)

El siguiente **código** muestra cómo **calcular el ECI** de dos formas:

1.  Usando la estimación de **personal de trabajadores** por industria.

2.  Usando el número de **unidades económicas.**

No se explicará en detalle cómo funciona el código.

```{r ECI_archivo}
directorio = "Datos/Originales/Hidalgo/"
archivos_csv = list.files(path = directorio, 
                          pattern = ".csv", 
                          all.files = T, 
                          recursive = T, 
                          full.names = T)

archivos_csv = archivos_csv[!grepl("diccionario", archivos_csv)]
nombres = archivos_csv |>  dirname() |>  dirname() |>  basename()

cat("El archivo csv ha abrir es: ", archivos_csv, "\n")
cat("El archivo csv tiene el nombre: ", nombres, "\n")
```

Unicamente verifica que este abriendo el archivo **denue_inegi_13\_.csv** y que el nombre del archivo sea con el correspondiente que renombraste.

```{r ECI}
#| message: false
#| warning: false
i = 1
denue = read.csv(archivos_csv[i]) |> 
  dplyr::filter(cve_ent == 13)

####################
### ICE Personal ###
####################

denue_P = denue  |> 
  dplyr::mutate(per_ocu = dplyr::case_when(
    per_ocu == "0 a 5 personas" ~ "2.5",
    per_ocu == "6 a 10 personas" ~ "8",
    per_ocu == "11 a 30 personas" ~ "20.5",
    per_ocu == "31 a 50 personas" ~ "40.5",
    per_ocu == "51 a 100 personas" ~ "75.5",
    per_ocu == "101 a 250 personas" ~ "175.5",
    per_ocu %in% c("251 y más personas", "251 y m\xe1s personas") ~ "251",
    TRUE ~ per_ocu  
  ),
  per_ocu = as.numeric(per_ocu),
  cvegeo = paste0("13", sprintf("%03d", cve_mun))) |> 
  dplyr::group_by(cvegeo, codigo_act) |> 
  dplyr::summarise(suma_per_ocu = sum(per_ocu, na.rm = T))


balassa_P = economiccomplexity::balassa_index(trade_data = denue_P, country = "cvegeo", product = "codigo_act", value = "suma_per_ocu")
complejidad_P = economiccomplexity::complexity_measures(
  balassa_index = balassa_P,
  method = "eigenvalues"
)


ICE_P = data.frame(
  names(complejidad_P$complexity_index_country),
  complejidad_P$complexity_index_country
)

names(ICE_P) = c("CVEGEO", paste0("ICE_Personal_", nombres[i]))



####################
### ICE UNIDADES ###
####################

denue_U = denue  |> 
  dplyr::mutate(cvegeo = paste0("13", sprintf("%03d", cve_mun))) |> 
  dplyr::group_by(cvegeo, codigo_act) |> 
  dplyr::summarise(suma_unidades = dplyr::n()) |>  
  dplyr::ungroup() 


complejidad_U = economiccomplexity::complexity_measures(
  balassa_index = economiccomplexity::balassa_index(trade_data = denue_U, country = "cvegeo", product = "codigo_act", value = "suma_unidades"),
  method = "eigenvalues"
)

ICE_U = data.frame(
  names(complejidad_U$complexity_index_country),
  complejidad_U$complexity_index_country
)

names(ICE_U) = c("CVEGEO", paste0("ICE_Unidades_", nombres[i]))


ICE = merge(x = ICE_P, y = ICE_U, by = "CVEGEO", all.x = T)

ICE |>  head()
```

El resultado debe ser un **data.frame** con 3 columnas:

-   **CVEGEO**

-   **ICE_Personal_2025A**

-   **ICE_Unidades_2025A**

*Nota: El nombre de las columnas depende del periodo que descargaste. Por ejemplo:*

-   *Si descargaste **2025A** se llamarán ICE_Personal_2025A y ICE_Unidades_2025A.*

-   *Si fuera **2025B**, entonces serían ICE_Personal_2025B y ICE_Unidades_2025B.*

Como es una **actualización del tablero**, necesitas tener antes los **Índices de Complejidad Económica** previos, que en este caso están en el archivo **estatal.csv.** El archivo se visualiza asi:

![](Img/ICE_Captura_archivo.png)

Asi que adjuntaremos lo obtenido previamente ha dicho archivo.

```{r ECI_previos}
ICE_previo = read.csv("Datos/Procesados/Antiguos/estatal.csv")
personal_previo = names(ICE_previo) |>  grep(pattern = "ICE_Personal", value = T)
personal_previo = personal_previo[length(personal_previo)]  
unidades_previo = names(ICE_previo) |>  grep(pattern = "ICE_Unidades", value = T)
unidades_previo = unidades_previo[length(unidades_previo)]

cat("El ultimo realizado ICE Personal es: ", personal_previo, "\n")
cat("El ultimo realizado ICE Unidades es: ", unidades_previo, "\n")
```

***Nota:** Aqui en la linea de codigo donde se encuentran los **dplyr::relocate** si debes modificar manualmente los nombres de las columnas.*

```{r ECI_guardar}

ICE_actualizado = merge(x = ICE_previo, y = ICE, by = "CVEGEO")
ICE_actualizado = ICE_actualizado |> 
  dplyr::relocate(ICE_Personal_2025A, .after = ICE_Personal_2024B) |> 
  dplyr::relocate(ICE_Unidades_2025A, .after = ICE_Unidades_2024B)


write.csv(ICE_actualizado, "Datos/Procesados/Actualizados/estatal.csv", row.names = F, fileEncoding = "UTF-8")
```

## Afinidad y Complejidad del producto.

La afinidad indica la probabilidad de que un estado comience o deje de desarrollar una determinada actividad, mientras que la complejidad está asociada con mayores niveles de ingresos, crecimiento económico, menor desigualdad de ingresos, etc. De esta manera, el gráfico Afinidad-Complejidad compara el riesgo y el valor estratégico en oportunidades para desarrollar una actividad industrial en un estado. Cada círculo muestra una industria, y su tamaño refleja el número aproximado de empleados.

![](Img/Afinidad_Complejidad_Vista_General.png)

En este caso se usarán todos los datos nacionales. Para ello, es necesario abrir todos los archivos y unirlos para poder hacer uso del calculo de afinidad.

```{r abrir_archivos_nacional}
directorio = "Datos/Originales/Nacional/2025A/"
archivos_csv = list.files(path = directorio, pattern = "\\.csv$", all.files = T, full.names = T, recursive = T)
archivos_csv = archivos_csv[!grepl("diccionario", archivos_csv)]


archivos = lapply(archivos_csv, function(x) {
  df = read.csv(x)
  df = df |>  
    dplyr::select(cve_ent, cve_mun, cve_loc, codigo_act, per_ocu)
  df
})

datos = dplyr::bind_rows(archivos)

```

Con todos los archivos CSV unidos en un solo data.frame llamado datos, se realizará el cálculo de la afinidad, no se explicará en detalle cómo funciona el código.

```{r afinidad_complejidad_calculo}
df = datos

denue = datos

datos = denue  |> 
  dplyr::mutate(per_ocu = dplyr::case_when(
    per_ocu == "0 a 5 personas" ~ "2.5",
    per_ocu == "6 a 10 personas" ~ "8",
    per_ocu == "11 a 30 personas" ~ "20.5",
    per_ocu == "31 a 50 personas" ~ "40.5",
    per_ocu == "51 a 100 personas" ~ "75.5",
    per_ocu == "101 a 250 personas" ~ "175.5",
    per_ocu %in% c("251 y más personas", "251 y m\xe1s personas") ~ "251",
    TRUE ~ per_ocu  
  ),
  per_ocu = as.numeric(per_ocu)
  ) |> 
  dplyr::group_by(cve_ent, codigo_act) |> 
  dplyr::summarise(suma_per_ocu = sum(per_ocu, na.rm = T))

# Calculo de balassa
M = economiccomplexity::balassa_index(trade_data = datos, country = "cve_ent", product = "codigo_act", value = "suma_per_ocu")

# Indice de complejidad producto
complejidad =  economiccomplexity::complexity_measures(balassa_index = M, method = "eigenvalues" ) 
complejidad_producto = data.frame(names(complejidad$complexity_index_product), complejidad$complexity_index_product)
names(complejidad_producto) = c("codigo_act", "complejidad_producto")


# Afinidad
phi = economiccomplexity::proximity(M)
phi_product = as.matrix(phi$proximity_product)
I = diag(length(rowSums(as.matrix(phi_product))))*(1/rowSums(as.matrix(phi_product)))
matriz_afinidad = (as.matrix(M) %*% t(as.matrix(phi_product))) %*% I
colnames(matriz_afinidad) = colnames(phi_product)
afinidad = cbind(colnames(matriz_afinidad), matriz_afinidad[13,])  # Afinidad de hidalgo
colnames(afinidad) = c("codigo_act", "afinidad")



# Personal por producto
personal = datos |> dplyr::filter(cve_ent == 13) |>
  dplyr::group_by(codigo_act) |>
  dplyr::summarise(personal_ocupado = sum(suma_per_ocu))

preparacion_afinidad = merge(x = complejidad_producto, y = afinidad, by.x = "codigo_act", by.y = "codigo_act" )
preparacion_afinidad = merge(x = preparacion_afinidad, y = personal, by.x = "codigo_act", by.y = "codigo_act" )

nombres = directorio |>  basename()
names(preparacion_afinidad)[2:ncol(preparacion_afinidad)] = paste0(names(preparacion_afinidad)[2:ncol(preparacion_afinidad)], "_", nombres)

preparacion_afinidad |>  head()
```

El resultado debe ser un **data.frame** con 4 columnas:

-   **codigo_act**

-   **complejidad_producto_2025A**

-   **afinidad_2025A**

-   **personal_ocupado_2025A**

*Nota: El nombre de las columnas depende del periodo que descargaste. Por ejemplo:*

-   *Si descargaste **2025A** se llamarán complejidad_producto_2025A, analogamente las demas columnas.*

-   *Si fuera **2025B**, entonces serían complejidad_producto_2025B, analogamente las demas columnas.*

Como es una **actualización del tablero**, necesitas tener antes los **Afinidad y Complejidad del Productos** previos, que en este caso están en el archivo **afinidad_6_nombres.csv.** El archivo se visualiza asi:

![](Img/Afinidad_Complejidad_Datos_Vista_General.png)

Asi que adjuntaremos lo obtenido previamente ha dicho archivo.

```{r afinidad_guardar}
afinidad_previo = read.csv("Datos/Procesados/Antiguos/afinidad_6_nombres.csv")

afinidad_actualizado = merge(x = afinidad_previo, y = preparacion_afinidad, by = "codigo_act", all.x = T, all.y = T)
afinidad_actualizado = afinidad_actualizado |> 
  dplyr::relocate(complejidad_producto_2025A:personal_ocupado_2025A, .after = personal_ocupado_2024B) |> 
  dplyr::relocate(afinidad_2025A, .after = complejidad_producto_2025A) |> 
  dplyr::relocate(personal_ocupado_2025A, .after = afinidad_2025A)  


scian = readxl::read_excel("Datos/scian_2023_categorias_y_productos.xlsx")[,c(1,2)]
names(scian) = scian[1,]
scian = scian[-1,]

scian = scian |> 
  dplyr::filter(!is.na(Código))

scian_seis = scian |> 
  dplyr::filter(nchar(Código) == 6) |> 
  dplyr::mutate(Título = sub("T$", "", Título))

scian_dos = scian |> 
  dplyr::filter(nchar(Código) == 2) |> 
  dplyr::mutate(Título = sub("T$", "", Título)) |> 
  dplyr::rename(Título_dos_digitos = Título)

afinidad_actualizado = afinidad_actualizado |> 
  dplyr::select(-Título,-codigo_act_dos_digitos,-Título_dos_digitos)



afinidad_actualizado = merge(x = afinidad_actualizado, y = scian_seis, by.x = "codigo_act", by.y = "Código", all.x = T)
afinidad_actualizado = afinidad_actualizado |> 
  dplyr::relocate(Título, .after = codigo_act) |> 
  dplyr::mutate(codigo_act_dos_digitos = substr(x = codigo_act, start = 1, stop = 2))

afinidad_actualizado = merge(x = afinidad_actualizado, y = scian_dos, by.x = "codigo_act_dos_digitos", by.y = "Código", all.x = T)
afinidad_actualizado = afinidad_actualizado |> 
  dplyr::relocate(codigo_act_dos_digitos, .before = Título_dos_digitos) |> 
  dplyr::mutate(Título_dos_digitos  = dplyr::case_when(
    codigo_act_dos_digitos %in% c(31, 32, 33) ~ "Industrias manufactureras",
    codigo_act_dos_digitos %in% c(48, 49) ~ "Transportes, correos y almacenamiento",
    TRUE ~ Título_dos_digitos  
  )) |> 
  dplyr::arrange(codigo_act)

write.csv(afinidad_actualizado, "Datos/Procesados/Actualizados/afinidad_6_nombres.csv", row.names = F, fileEncoding = "UTF-8")
```

## Diversidad y Ubicuidad promedio.

-   **Diversidad** indica el número de actividades económicas en las que está especializada cada entidad.

-   **Ubicuidad** indica cuántas entidades están especializadas en cada actividad económica.

Las entidades **peor posicionadas** están en el **primer cuadrante** (superior derecha), donde muestran baja diversidad y alta ubicuidad. En contraste, las entidades que se **posicionan mejor** se encuentran en el **cuarto cuadrante** (inferior derecha), caracterizado por alta diversificación y baja ubicuidad.

![](Img/Diversidad_Ubicuidad_Vista_General.png)

No se explicará en detalle cómo funciona el código.

```{r afinidad_complejidad_archivo}
directorio = "Datos/Originales/Hidalgo/"
archivos_csv = list.files(path = directorio, 
                          pattern = ".csv", 
                          all.files = T, 
                          recursive = T, 
                          full.names = T)

archivos_csv = archivos_csv[!grepl("diccionario", archivos_csv)]
nombres = archivos_csv |>  dirname() |>  dirname() |>  basename()

cat("El archivo csv ha abrir es: ", archivos_csv, "\n")
cat("El archivo csv tiene el nombre: ", nombres, "\n")
```

Unicamente verifica que este abriendo el archivo **denue_inegi_13\_.csv** y que el nombre del archivo sea con el correspondiente que renombraste.

```{r Diversidad_Ubicuidad_calculo}
#| message: false
#| warning: false
i = 1
denue = read.csv(archivos_csv[i]) |> 
  dplyr::filter(cve_ent == 13)

####################
### ICE Personal ###
####################

denue_P = denue  |> 
  dplyr::mutate(per_ocu = dplyr::case_when(
    per_ocu == "0 a 5 personas" ~ "2.5",
    per_ocu == "6 a 10 personas" ~ "8",
    per_ocu == "11 a 30 personas" ~ "20.5",
    per_ocu == "31 a 50 personas" ~ "40.5",
    per_ocu == "51 a 100 personas" ~ "75.5",
    per_ocu == "101 a 250 personas" ~ "175.5",
    per_ocu %in% c("251 y más personas", "251 y m\xe1s personas") ~ "251",
    TRUE ~ per_ocu  
  ),
  per_ocu = as.numeric(per_ocu),
  cvegeo = paste0("13", sprintf("%03d", cve_mun))) |> 
  dplyr::group_by(cvegeo, codigo_act) |> 
  dplyr::summarise(suma_per_ocu = sum(per_ocu, na.rm = T))


balassa_P = economiccomplexity::balassa_index(trade_data = denue_P, country = "cvegeo", product = "codigo_act", value = "suma_per_ocu")
complejidad_P = economiccomplexity::complexity_measures(
  balassa_index = balassa_P,
  method = "eigenvalues"
)


ICE_P = data.frame(
  names(complejidad_P$complexity_index_country),
  complejidad_P$complexity_index_country
)

names(ICE_P) = c("CVEGEO", paste0("ICE_Personal_", nombres[i]))


M = balassa_P |>  as.matrix()
diversidad = rowSums(M)
ubicuidad = colSums(M)
especializado = (1/diversidad)*(M%*%ubicuidad)
datos_grafica = cbind(c(1:nrow(M)), diversidad, especializado)
colnames(datos_grafica) = c("CVE_MUN", paste0("diversidad_", nombres[i]) , paste0("especializado_", nombres[i]))
datos_grafica = datos_grafica |>  as.data.frame()

datos_grafica |>  head()
```

El resultado debe ser un **data.frame** con 3 columnas:

-   **CVE_MUN**

-   **diversidad_2025A**

-   **especializado_2025A**

*Nota: El nombre de las columnas depende del periodo que descargaste. Por ejemplo:*

-   *Si descargaste **2025A** se llamarán diversidad_2025A y especializado_2025A.*

-   *Si fuera **2025B**, entonces serían diversidad_2025B y especializado_2025B.*

Como es una **actualización del tablero**, necesitas tener antes los **Índices de Complejidad Económica** previos, que en este caso están en el archivo **dive_vs_ubi_6_mun.csv.** El archivo se visualiza asi:

![](Img/Diversidad_Ubicuidad_Datos_Previo.png)

Asi que adjuntaremos lo obtenido previamente ha dicho archivo.

```{r Diversidad_Ubicuidad_guardar}
diversidad_ubicuidad_previo = read.csv("Datos/Procesados/Antiguos/dive_vs_ubi_6_mun.csv")
diversidad_ubicuidad_actualizado = merge(x = diversidad_ubicuidad_previo, y = datos_grafica, by = "CVE_MUN")

write.csv(diversidad_ubicuidad_actualizado, "Datos/Procesados/Actualizados/dive_vs_ubi_6_mun.csv", row.names = F, fileEncoding = "UTF-8")
```

## Red Hidalgo

Es una red en la que cada nodo corresponde a un municipio y los nodos se conectan si existen productos similares, lo que sugiere que comparten habilidades, conocimientos y tecnología parecidas. Los colores de los nodos representan la región a la que pertenecen y su tamaño refleja el número aproximado de empleados.

![](Img/Espacio_Entidades_Vista_General.png)

En este apartado se crea un archivo nuevo, el cual debe tener la siguiente estructura:

![](Img/Espacio_Entidades_Datos_Previos.png)

Estos archivos suelen tener por nombre **Red_Hidalgo_2024B.** No se explicará en detalle cómo funciona el código.

```{r Red_Hidalgo_archivo}
directorio = "Datos/Originales/Hidalgo/"
archivos_csv = list.files(path = directorio, 
                          pattern = ".csv", 
                          all.files = T, 
                          recursive = T, 
                          full.names = T)

archivos_csv = archivos_csv[!grepl("diccionario", archivos_csv)]
nombres = archivos_csv |>  dirname() |>  dirname() |>  basename()

cat("El archivo csv ha abrir es: ", archivos_csv, "\n")
cat("El archivo csv tiene el nombre: ", nombres, "\n")
```

Unicamente verifica que este abriendo el archivo **denue_inegi_13\_.csv** y que el nombre del archivo sea con el correspondiente que renombraste.

```{r Red_Hidalgo_realizar_guardar}
#| message: false
#| warning: false
i = 1
denue = read.csv(archivos_csv[i]) |> 
  dplyr::filter(cve_ent == 13)

####################
### ICE Personal ###
####################

denue_P = denue  |> 
  dplyr::mutate(per_ocu = dplyr::case_when(
    per_ocu == "0 a 5 personas" ~ "2.5",
    per_ocu == "6 a 10 personas" ~ "8",
    per_ocu == "11 a 30 personas" ~ "20.5",
    per_ocu == "31 a 50 personas" ~ "40.5",
    per_ocu == "51 a 100 personas" ~ "75.5",
    per_ocu == "101 a 250 personas" ~ "175.5",
    per_ocu %in% c("251 y más personas", "251 y m\xe1s personas") ~ "251",
    TRUE ~ per_ocu  
  ),
  per_ocu = as.numeric(per_ocu),
  cvegeo = paste0("13", sprintf("%03d", cve_mun))) |> 
  dplyr::group_by(cvegeo, codigo_act) |> 
  dplyr::summarise(suma_per_ocu = sum(per_ocu, na.rm = T))


balassa_matriz = economiccomplexity::balassa_index(trade_data = denue_P, country = "cvegeo", product = "codigo_act", value = "suma_per_ocu")
pro = economiccomplexity::proximity(balassa_matriz)
net = economiccomplexity::projections(pro$proximity_country, pro$proximity_product)

pesos_grafo = denue_P |> dplyr::group_by(cvegeo) |>
  dplyr::summarise(peso_nodo1 = sum(suma_per_ocu, na.rm = TRUE))

pais = net$network_country
peso_aristas = igraph::edge_attr(pais, "weight")
conexiones = igraph::as_edgelist(pais)
interes = as.data.frame(cbind(conexiones,peso_aristas ))
colnames(interes) = c("nodo1", "nodo2", "peso_arista")


p = merge(x = interes, y = pesos_grafo, by.x = "nodo1", by.y = "cvegeo")
colnames(pesos_grafo)[2] = "peso_nodo2"

p = merge(x = p, y = pesos_grafo, by.x = "nodo2", by.y = "cvegeo")
p = p[, c(2,1,3:5)]

p = p |>
  dplyr::mutate(nodo1 = as.numeric(nodo1), nodo2 = as.numeric(nodo2)) |>
  dplyr::arrange(nodo1,nodo2)


datos = p
datos = datos |> 
  dplyr::mutate(nodo1 = as.character(nodo1),
                nodo2 = as.character(nodo2),
                nodo1 = substr(x = nodo1, start = 3, stop = nchar(nodo1)),
                nodo2 = substr(x = nodo2, start = 3, stop = nchar(nodo2)),
                nodo1 = as.numeric(nodo1),
                nodo2 = as.numeric(nodo2),
                )

nombres_mun = readxl::read_excel("Datos/Banco de datos infografias _Eduardo.xlsx")
nombres_mun = nombres_mun |> 
  dplyr::filter(!is.na(Región)) 
nombres_mun = nombres_mun |> 
  dplyr::mutate(CVE_MUN = 1:nrow(nombres_mun)) |>
  dplyr::select(CVE_MUN, Municipio, Región)

datos = merge(x = datos, y = nombres_mun, by.x = "nodo1", by.y = "CVE_MUN", all.x = T)
datos = datos |> 
  dplyr::rename(nodo1_nombre = Municipio,
                nodo1_region = Región)

datos = merge(x = datos, y = nombres_mun, by.x = "nodo2", by.y = "CVE_MUN", all.x = T)
datos = datos |> 
  dplyr::rename(nodo2_nombre = Municipio,
                nodo2_region = Región) |> 
  dplyr::relocate(nodo2_nombre, .after = nodo1_nombre) |> 
  dplyr::relocate(nodo2_region, .after = nodo1_region) |> 
  dplyr::relocate(nodo2, .after = nodo1) |> 
  dplyr::arrange(nodo1, nodo2)

write.csv(datos, paste0("Datos/Procesados/Actualizados/", "Red_Hidalgo_", nombres[i],".csv"), row.names = F, fileEncoding = "UTF-8")

```

## Espacio Producto

El espacio de producto es una red en la que cada nodo corresponde a un producto, y los nodos se conectan si existe una alta probabilidad de ser coproducidos. Esto implica que los productos conectados comparten requisitos similares en términos de capacidades productivas, conocimientos y tecnologías. Puede ser utilizado para predecir actividades futuras y el crecimiento económico de un país. Los colores de los nodos representan un sector industrial y su tamaño refleja el número aproximado de empleados.

![](Img/Espacio_Producto_Vista_General.png)

En este apartado se crea un archivo nuevo, el cual debe tener la siguiente estructura:

![](Img/Grafo_Hidalgo_General.png)

Estos archivos suelen tener por nombre **grafo_hgo_2024B.** No se explicará en detalle cómo funciona el código.

```{r Espacio_Producto_archivo}
directorio = "Datos/Originales/Hidalgo/"
archivos_csv = list.files(path = directorio, 
                          pattern = ".csv", 
                          all.files = T, 
                          recursive = T, 
                          full.names = T)

archivos_csv = archivos_csv[!grepl("diccionario", archivos_csv)]
nombres = archivos_csv |>  dirname() |>  dirname() |>  basename()

cat("El archivo csv ha abrir es: ", archivos_csv, "\n")
cat("El archivo csv tiene el nombre: ", nombres, "\n")
```

Unicamente verifica que este abriendo el archivo **denue_inegi_13\_.csv** y que el nombre del archivo sea con el correspondiente que renombraste.

```{r Espacio_Producto_Calculo}


i = 1
denue = read.csv(archivos_csv[i]) |> 
  dplyr::filter(cve_ent == 13)

####################
### ICE Personal ###
####################

denue_P = denue  |> 
  dplyr::mutate(per_ocu = dplyr::case_when(
    per_ocu == "0 a 5 personas" ~ "2.5",
    per_ocu == "6 a 10 personas" ~ "8",
    per_ocu == "11 a 30 personas" ~ "20.5",
    per_ocu == "31 a 50 personas" ~ "40.5",
    per_ocu == "51 a 100 personas" ~ "75.5",
    per_ocu == "101 a 250 personas" ~ "175.5",
    per_ocu %in% c("251 y más personas", "251 y m\xe1s personas") ~ "251",
    TRUE ~ per_ocu  
  ),
  per_ocu = as.numeric(per_ocu),
  cvegeo = paste0("13", sprintf("%03d", cve_mun))) |> 
  dplyr::group_by(cvegeo, codigo_act) |> 
  dplyr::summarise(suma_per_ocu = sum(per_ocu, na.rm = T))

balassa_matriz = economiccomplexity::balassa_index(trade_data = denue_P, country = "cvegeo", product = "codigo_act", value = "suma_per_ocu")
pro = economiccomplexity::proximity(balassa_matriz)
net = economiccomplexity::projections(pro$proximity_country, pro$proximity_product)

pesos_grafo = denue_P |> dplyr::group_by(codigo_act) |>
  dplyr::summarise(peso_nodo1 = sum(suma_per_ocu, na.rm = TRUE))

pais = net$network_product
peso_aristas = igraph::edge_attr(pais, "weight")
conexiones = igraph::as_edgelist(pais)
interes = as.data.frame(cbind(conexiones,peso_aristas ))
colnames(interes) = c("nodo1", "nodo2", "peso_arista")

p = merge(x = interes, y = pesos_grafo, by.x = "nodo1", by.y = "codigo_act")
colnames(pesos_grafo)[2] = "peso_nodo2"

p = merge(x = p, y = pesos_grafo, by.x = "nodo2", by.y = "codigo_act")
p = p[, c(2,1,3:5)]

p = p |>
  dplyr::mutate(nodo1 = as.numeric(nodo1), nodo2 = as.numeric(nodo2)) |>
  dplyr::arrange(nodo1,nodo2)

p |>  head()

```

El resultado debe ser un **data.frame** con 5 columnas:

-   **nodo1**

-   **nodo2**

-   **peso_arista**

-   **peso_nodo1**

-   **peso_nodo2**

Para el siguiente paso, necesitamos el **archivo afinidad_6_nombres.csv**, generado en el apartado de **Afinidad y Complejidad del producto**, para agregarle las demás columnas.

```{r producto_guardar}

afinidad = read.csv("Datos/Procesados/Actualizados/afinidad_6_nombres.csv")
afinidad = afinidad |> 
  dplyr::select(codigo_act, Título, afinidad_2025A, codigo_act_dos_digitos, Título_dos_digitos) |> 
  dplyr::filter(! is.na(afinidad_2025A))

producto = merge(x = p, y = afinidad, by.x = "nodo1", by.y = "codigo_act", all.x = T)
producto = producto |> 
  dplyr::rename(nodo1_nombre = Título,
                nodo1_afinidad = afinidad_2025A,
                nodo1_dos_digitos = codigo_act_dos_digitos,
                nodo1_dos_digitos_nombre = Título_dos_digitos)

producto = merge(x = producto, y = afinidad, by.x = "nodo2", by.y = "codigo_act", all.x = T)
producto = producto |> 
  dplyr::rename(nodo2_nombre = Título,
                nodo2_afinidad = afinidad_2025A,
                nodo2_dos_digitos = codigo_act_dos_digitos,
                nodo2_dos_digitos_nombre = Título_dos_digitos) |> 
  dplyr::select(nodo1, nodo2, nodo1_nombre, nodo2_nombre, 
                peso_arista, peso_nodo1, peso_nodo2, 
                nodo1_afinidad, nodo2_afinidad,
                nodo1_dos_digitos, nodo2_dos_digitos, nodo1_dos_digitos_nombre, nodo2_dos_digitos_nombre) |> 
  dplyr::arrange(nodo1, nodo2)


write.csv(producto, paste0("Datos/Procesados/Actualizados/", "grafo_hgo_", nombres[i],".csv"), row.names = F, fileEncoding = "UTF-8")
```
